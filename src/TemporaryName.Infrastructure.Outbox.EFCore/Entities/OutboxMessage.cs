using TemporaryName.Domain.Primitives.Outbox;

namespace TemporaryName.Infrastructure.Outbox.EFCore.Entities;

/// <summary>
/// Represents a message to be published, stored in the database as part of the transactional outbox pattern.
/// This entity is persisted in the same transaction as the business data changes.
/// Debezium will monitor the table corresponding to this entity.
/// Its structure is designed to contain all information needed to construct the OutboxMessageProto
/// and to support auditing, monitoring, and potential fallback polling mechanisms.
/// </summary>
public class OutboxMessage
{
    /// <summary>
    /// Primary key for the outbox message entry. This is typically a GUID.
    /// This ID is distinct from the EventId of the domain event it encapsulates.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// The unique identifier of the domain event that this outbox message represents.
    /// This ID is generated by the domain event itself and is crucial for idempotency
    /// in downstream consumers.
    /// </summary>
    public Guid EventId { get; private set; }

    /// <summary>
    /// Fully qualified .NET type name of the original domain event.
    /// Example: "TemporaryName.Domain.Aggregates.Orders.Events.OrderCreatedDomainEvent"
    /// This is used by the OutboxEventRelayService (via MassTransitIntegrationEventPublisher)
    /// to deserialize the JSON payload back into the correct POCO domain event type.
    /// </summary>
    public string EventTypeFqn { get; private set; }

    /// <summary>
    /// The domain event payload, serialized as a JSON string.
    /// The MassTransitIntegrationEventPublisher will deserialize this JSON, then map the
    /// resulting POCO to a Protobuf integration event for publishing on the bus.
    /// </summary>
    public string PayloadJson { get; private set; }

    /// <summary>
    /// Timestamp indicating when the domain event originally occurred (UTC).
    /// This is sourced from the domain event itself.
    /// </summary>
    public DateTimeOffset OccurredAtUtc { get; private set; }

    /// <summary>
    /// Timestamp indicating when this outbox message was persisted to the database (UTC).
    /// This is typically set by the ConvertDomainEventsToOutboxMessagesInterceptor.
    /// </summary>
    public DateTimeOffset PersistedAtUtc { get; private set; }

    /// <summary>
    /// Type/name of the aggregate root that originated the event.
    /// Example: "Order", "UserProfile", "Product". Used for categorization and context.
    /// </summary>
    public string AggregateType { get; private set; }

    /// <summary>
    /// Identifier (as a string) of the specific aggregate root instance that this event pertains to.
    /// Example: "ORD-2024-00123", "USR-98765", or a GUID string.
    /// </summary>
    public string AggregateId { get; private set; }

    /// <summary>
    /// Optional: Version of the aggregate root after this event was applied.
    /// Useful for optimistic concurrency checks by consumers or for event sourcing diagnostics.
    /// </summary>
    public long? AggregateVersion { get; private set; }

    /// <summary>
    /// Optional: Correlation ID for tracing a logical operation or request across multiple services and events.
    /// Should be propagated from the initial request or command that led to this event.
    /// </summary>
    public Guid? CorrelationId { get; private set; }

    /// <summary>
    /// Optional: Causation ID, linking this event to a preceding command or event that caused it.
    /// Helps in understanding the chain of events and debugging.
    /// </summary>
    public Guid? CausationId { get; private set; }

    /// <summary>
    /// Optional: Identifier for the user or system principal that initiated the action leading to this event.
    /// Example: "user-auth0|abcdef123", "system-batch-processor-orders".
    /// </summary>
    public string? UserId { get; private set; }

    /// <summary>
    /// Optional: Tenant identifier if the system is multi-tenant.
    /// Example: "tenant-acme-corp-001".
    /// </summary>
    public string? TenantId { get; private set; }

    /// <summary>
    /// Optional: Distributed tracing context (e.g., W3C TraceParent and TraceState), stored as a JSON string.
    /// This allows linking this event to distributed traces in systems like Jaeger or OpenTelemetry.
    /// Example JSON: {"traceparent": "00-...", "tracestate": "..."}
    /// </summary>
    public string? TraceContextJson { get; private set; }

    /// <summary>
    /// Version of the OutboxMessageProto schema that this message's data structure corresponds to.
    /// Debezium will use this information (implicitly via its Protobuf converter configuration)
    /// to serialize this data into the correct Protobuf message format.
    /// Example: "1.0", "1.1".
    /// </summary>
    public string ProtoSchemaVersion { get; private set; }

    /// <summary>
    /// Arbitrary metadata associated with the event or its outbox entry, stored as a JSON string.
    /// This provides an extension point for additional contextual information (e.g., source system, data sensitivity).
    /// Example JSON: {"source_application": "OrderService", "data_sensitivity": "PII", "feature_flag_x": "enabled"}
    /// </summary>
    public string? MetadataJson { get; private set; }

    /// <summary>
    /// Status of the outbox message. While Debezium reads based on row insertion, this status
    /// can be invaluable for monitoring, diagnostics, and potential fallback polling/cleanup mechanisms.
    /// It indicates the state from the perspective of the application's outbox system, not necessarily Kafka.
    /// </summary>
    public OutboxMessageStatus Status { get; set; } // Setter can be internal or public for admin/poller updates

    /// <summary>
    /// Number of processing attempts by a fallback poller (if implemented).
    /// Not directly used by the primary Debezium->Kafka->Relay flow.
    /// </summary>
    public int ProcessAttemptCount { get; set; }

    /// <summary>
    /// Timestamp of the last processing attempt (UTC) by a fallback poller.
    /// </summary>
    public DateTimeOffset? LastProcessAttemptAtUtc { get; set; }

    /// <summary>
    /// Error message if the last processing attempt by a fallback poller failed.
    /// </summary>
    public string? LastProcessError { get; set; }


#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. EF Core handles this.
    // Private constructor for EF Core hydration
    private OutboxMessage() { }
#pragma warning restore CS8618

    /// <summary>
    /// Creates a new OutboxMessage instance.
    /// This constructor is typically called by the ConvertDomainEventsToOutboxMessagesInterceptor.
    /// </summary>
    public OutboxMessage(
        Guid eventId,
        string eventTypeFqn,
        string payloadJson,
        DateTimeOffset occurredAtUtc,
        string aggregateType,
        string aggregateId,
        long? aggregateVersion,
        Guid? correlationId,
        Guid? causationId,
        string? userId,
        string? tenantId,
        string? traceContextJson,
        string protoSchemaVersion, // Ensure this matches the version of outbox_message.v1.proto you expect Debezium to use
        string? metadataJson)
    {
        Id = Guid.NewGuid(); // Unique PK for this outbox database entry
        EventId = eventId;
        EventTypeFqn = !string.IsNullOrWhiteSpace(eventTypeFqn) ? eventTypeFqn : throw new ArgumentNullException(nameof(eventTypeFqn));
        PayloadJson = !string.IsNullOrWhiteSpace(payloadJson) ? payloadJson : throw new ArgumentNullException(nameof(payloadJson));
        OccurredAtUtc = occurredAtUtc;
        PersistedAtUtc = DateTime.UtcNow; // Set at the moment this outbox record is being prepared for persistence
        AggregateType = !string.IsNullOrWhiteSpace(aggregateType) ? aggregateType : throw new ArgumentNullException(nameof(aggregateType));
        AggregateId = !string.IsNullOrWhiteSpace(aggregateId) ? aggregateId : throw new ArgumentNullException(nameof(aggregateId));
        AggregateVersion = aggregateVersion;
        CorrelationId = correlationId;
        CausationId = causationId;
        UserId = userId;
        TenantId = tenantId;
        TraceContextJson = traceContextJson;
        ProtoSchemaVersion = !string.IsNullOrWhiteSpace(protoSchemaVersion) ? protoSchemaVersion : throw new ArgumentNullException(nameof(protoSchemaVersion));
        MetadataJson = metadataJson;
        Status = OutboxMessageStatus.Pending; // Initial status when first created
        ProcessAttemptCount = 0;
    }

    // Methods for a potential fallback poller or administrative actions to update status.
    // These are not directly invoked by the Debezium-based relay for status changes.
    public void RecordPollingAttempt(bool success, string? errorMessage = null)
    {
        this.ProcessAttemptCount++;
        this.LastProcessAttemptAtUtc = DateTime.UtcNow;
        if (success)
        {
            this.Status = OutboxMessageStatus.ProcessedByConsumer;
            this.LastProcessError = null;
        }
        else
        {
            this.Status = OutboxMessageStatus.FailedToPublish; // Or a more specific retryable error status
            this.LastProcessError = errorMessage?.Length > 4000 ? errorMessage.Substring(0, 4000) : errorMessage; // Truncate if too long
        }
    }

    public void ResetForReprocessing()
    {
        this.Status = OutboxMessageStatus.Pending;
        this.LastProcessError = "Reset for reprocessing.";
        // ProcessAttemptCount might be reset or incremented based on strategy
    }
    public void MarkAsProcessing()
    {
        Status = OutboxMessageStatus.Processing;
        ProcessAttemptCount++;
        LastProcessAttemptAtUtc = DateTime.UtcNow;
        LastProcessError = null;
    }

    public void MarkAsRequeued(){
        Status = OutboxMessageStatus.Requeued;
        LastProcessAttemptAtUtc = DateTime.UtcNow;
        ProcessAttemptCount ++;
        LastProcessError = null;
    }

    public void MarkAsPublished(){
        Status = OutboxMessageStatus.Published;
        LastProcessAttemptAtUtc = DateTime.UtcNow;
        LastProcessError = null;
    }
    public void MarkAsProcessed()
    {
        Status = OutboxMessageStatus.ProcessedByConsumer;
        LastProcessAttemptAtUtc = DateTime.UtcNow; // Record successful processing time
        LastProcessError = null;
    }

    public void MarkAsFailed(string error)
    {
        Status = OutboxMessageStatus.FailedToPublish;
        LastProcessAttemptAtUtc = DateTime.UtcNow;
        LastProcessError = error.Length > 4000 ? error.Substring(0, 4000) : error; // Truncate if too long for DB
    }
}
// In your ApplicationDbContext.cs or a separate OutboxMessageEntityTypeConfiguration.cs

// using Microsoft.EntityFrameworkCore;
// using Microsoft.EntityFrameworkCore.Metadata.Builders;
// using TemporaryName.Infrastructure.Outbox.EFCore.Entities;
// using TemporaryName.Domain.Primitives.Outbox; // For OutboxMessageStatus

// public class OutboxMessageEntityTypeConfiguration : IEntityTypeConfiguration<OutboxMessage>
// {
//     public void Configure(EntityTypeBuilder<OutboxMessage> builder)
//     {
//         builder.ToTable("outbox_messages", "public"); // Match Debezium config: "public.outbox_messages"

//         builder.HasKey(om => om.Id);
//         builder.Property(om => om.Id).ValueGeneratedOnAdd();

//         builder.Property(om => om.EventId).IsRequired();
//         // Unique index on EventId is crucial to prevent accidental duplicate processing
//         // if an event somehow gets into the outbox table twice with the same EventId.
//         builder.HasIndex(om => om.EventId).IsUnique();

//         builder.Property(om => om.EventTypeFqn).IsRequired().HasMaxLength(512);
//         builder.Property(om => om.PayloadJson).IsRequired().HasColumnType("jsonb"); // For PostgreSQL; use "nvarchar(max)" for SQL Server

//         builder.Property(om => om.OccurredAtUtc).IsRequired();
//         builder.Property(om => om.PersistedAtUtc).IsRequired();
//         builder.HasIndex(om => om.PersistedAtUtc).HasDatabaseName("IX_OutboxMessages_PersistedAtUtc"); // For querying/cleanup

//         builder.Property(om => om.AggregateType).IsRequired().HasMaxLength(256);
//         builder.Property(om => om.AggregateId).IsRequired().HasMaxLength(256);
//         builder.Property(om => om.AggregateVersion); // Nullable long

//         builder.Property(om => om.CorrelationId); // Nullable Guid
//         builder.Property(om => om.CausationId);   // Nullable Guid

//         builder.Property(om => om.UserId).HasMaxLength(256);   // Nullable string
//         builder.Property(om => om.TenantId).HasMaxLength(128); // Nullable string

//         builder.Property(om => om.TraceContextJson).HasColumnType("jsonb"); // Nullable
//         builder.Property(om => om.ProtoSchemaVersion).IsRequired().HasMaxLength(32);
//         builder.Property(om => om.MetadataJson).HasColumnType("jsonb"); // Nullable

//         builder.Property(om => om.Status)
//                .IsRequired()
//                .HasConversion<string>() // Store enum as string for better readability in DB
//                .HasMaxLength(50);
//         // Index for fallback pollers or monitoring tools to find pending/failed messages
//         builder.HasIndex(om => new { om.Status, om.PersistedAtUtc }).HasDatabaseName("IX_OutboxMessages_Status_PersistedAtUtc");

//         builder.Property(om => om.ProcessAttemptCount).IsRequired().HasDefaultValue(0);
//         builder.Property(om => om.LastProcessAttemptAtUtc); // Nullable DateTime
//         builder.Property(om => om.LastProcessError).HasMaxLength(4000); // Max length for error messages
//     }
// }
